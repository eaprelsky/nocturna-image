<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nocturna Chart</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: white;
      font-family: Arial, sans-serif;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    body.dark {
      background: #1a1a1a;
    }

    #chart-container {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      min-width: 400px;
      min-height: 400px;
    }

    #chart-container svg {
      display: block;
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
    }
  </style>
</head>
<body>
  <div id="chart-container"></div>

  <!-- Include nocturna-wheel library - will be inlined by chartRenderer.service.js -->
  <script src="/nocturna-wheel/nocturna-wheel.min.js"></script>

  <script>
    console.log('Starting chart rendering...');
    console.log('NocturnaWheel available:', typeof NocturnaWheel);
    
    /* CHART_CONFIG_PLACEHOLDER */

    // Apply theme to body
    if (chartConfig.renderOptions?.theme === 'dark') {
      document.body.classList.add('dark');
    }

    // Set container dimensions explicitly
    const container = document.getElementById('chart-container');
    const width = chartConfig.renderOptions?.width || 800;
    const height = chartConfig.renderOptions?.height || 800;
    if (container) {
      container.style.width = width + 'px';
      container.style.height = height + 'px';
    }
    // Create chart configuration for nocturna-wheel
    // Library expects houses as array of OBJECTS with {lon: X} format
    // Keep houses in the original format from API
    const wheelConfig = {
      container: '#chart-container',  // CSS selector with '#'
      planets: chartConfig.planets || {},
      houses: chartConfig.houses || []  // Keep as objects: [{lon: 123}, {lon: 456}, ...]
    };

    // Add secondary planets if present (for transit/synastry)
    if (chartConfig.secondaryPlanets) {
      wheelConfig.secondaryPlanets = chartConfig.secondaryPlanets;
    }

    // Always create config object to ensure proper initialization
    wheelConfig.config = wheelConfig.config || {};

    // SVG dimensions
    if (chartConfig.renderOptions?.width) {
      const svgSize = chartConfig.renderOptions.width;
      wheelConfig.config.svg = {
        width: svgSize,
        height: svgSize
      };
    }

    // Helper function to build aspect types configuration
    // This function ALWAYS returns a complete types object with all required fields
    function buildAspectTypes(types, defaultOrb = 6) {
      const defaultAspects = {
        conjunction: { angle: 0, orb: 8, color: '#000000', enabled: true, lineStyle: 'none', strokeWidth: 1 },
        opposition: { angle: 180, orb: 6, color: '#E41B17', enabled: true, lineStyle: 'solid', strokeWidth: 1 },
        trine: { angle: 120, orb: 6, color: '#4CC417', enabled: true, lineStyle: 'solid', strokeWidth: 1 },
        square: { angle: 90, orb: 6, color: '#F62817', enabled: true, lineStyle: 'dashed', strokeWidth: 1 },
        sextile: { angle: 60, orb: 4, color: '#56A5EC', enabled: true, lineStyle: 'dashed', strokeWidth: 1 }
      };

      // If no types provided, return defaults
      if (!types) {
        return defaultAspects;
      }

      // Merge user types with defaults
      const result = {};
      for (const [name, defaults] of Object.entries(defaultAspects)) {
        const userType = types[name] || {};
        result[name] = {
          ...defaults,
          orb: userType.orb !== undefined ? userType.orb : (defaults.orb || defaultOrb),
          enabled: userType.enabled !== false,
          ...userType
        };
      }

      return result;
    }

    // Configure aspects for natal chart
    // For dual charts (transit/synastry), primaryAspectSettings comes from chartConfig.primaryAspectSettings
    // For single charts (natal), it comes from chartConfig.aspectSettings
    // IMPORTANT: Check primaryAspectSettings first because aspectSettings for transit charts
    // is an object with nested settings (natal, transit, natalToTransit) without top-level 'enabled'
    
    // DEBUG: Log what we have in chartConfig
    console.log('DEBUG: chartConfig.aspectSettings =', JSON.stringify(chartConfig.aspectSettings));
    console.log('DEBUG: chartConfig.primaryAspectSettings =', JSON.stringify(chartConfig.primaryAspectSettings));
    
    const aspectConfig = chartConfig.primaryAspectSettings || chartConfig.aspectSettings;
    console.log('DEBUG: aspectConfig =', JSON.stringify(aspectConfig));
    
    if (aspectConfig) {
      // Check if aspects are enabled (default to true if not specified)
      console.log('DEBUG: aspectConfig.enabled =', aspectConfig.enabled);
      console.log('DEBUG: aspectConfig.enabled !== false =', aspectConfig.enabled !== false);
      const aspectsEnabled = aspectConfig.enabled !== false;
      console.log('DEBUG: aspectsEnabled =', aspectsEnabled);
      
      wheelConfig.config.primaryAspectSettings = {
        enabled: aspectsEnabled,
        orb: aspectConfig.orb || 6
      };
      
      console.log('DEBUG: wheelConfig.config.primaryAspectSettings after setting =', JSON.stringify(wheelConfig.config.primaryAspectSettings));
      
      // Only add types if aspects are enabled
      if (aspectsEnabled) {
        wheelConfig.config.primaryAspectSettings.types = buildAspectTypes(aspectConfig.types, aspectConfig.orb || 6);
        console.log('PrimaryAspectSettings configured with types:', Object.keys(wheelConfig.config.primaryAspectSettings.types));
      } else {
        console.log('PrimaryAspectSettings DISABLED');
      }
    } else {
      // If no aspect settings provided, use defaults with types
      wheelConfig.config.primaryAspectSettings = {
        enabled: true,
        orb: 6,
        types: buildAspectTypes(null, 6)
      };
      console.log('Using default PrimaryAspectSettings with types:', Object.keys(wheelConfig.config.primaryAspectSettings.types));
    }

    // Configure aspects for transit/synastry charts
    if (chartConfig.secondaryAspectSettings) {
      const secondaryEnabled = chartConfig.secondaryAspectSettings.enabled !== false;
      
      wheelConfig.config.secondaryAspectSettings = {
        enabled: secondaryEnabled,
        orb: chartConfig.secondaryAspectSettings.orb || 6
      };
      
      if (secondaryEnabled) {
        wheelConfig.config.secondaryAspectSettings.types = buildAspectTypes(
          chartConfig.secondaryAspectSettings.types, 
          chartConfig.secondaryAspectSettings.orb || 6
        );
        console.log('SecondaryAspectSettings configured with types:', Object.keys(wheelConfig.config.secondaryAspectSettings.types));
      } else {
        console.log('SecondaryAspectSettings DISABLED');
      }
    }

    if (chartConfig.synastryAspectSettings) {
      const synastryEnabled = chartConfig.synastryAspectSettings.enabled !== false;
      
      wheelConfig.config.synastryAspectSettings = {
        enabled: synastryEnabled,
        orb: chartConfig.synastryAspectSettings.orb || 3
      };
      
      if (synastryEnabled) {
        wheelConfig.config.synastryAspectSettings.types = buildAspectTypes(
          chartConfig.synastryAspectSettings.types, 
          chartConfig.synastryAspectSettings.orb || 3
        );
        console.log('SynastryAspectSettings configured with types:', Object.keys(wheelConfig.config.synastryAspectSettings.types));
      } else {
        console.log('SynastryAspectSettings DISABLED');
      }
    }

    // Create and render the chart
    try {
      // Validate that NocturnaWheel is available
      if (typeof NocturnaWheel === 'undefined') {
        throw new Error('NocturnaWheel library is not loaded');
      }

      // Validate that WheelChart is available
      if (!NocturnaWheel.WheelChart) {
        console.error('NocturnaWheel available keys:', Object.keys(NocturnaWheel));
        throw new Error('WheelChart class is not available in NocturnaWheel');
      }

      // Validate required data
      if (!wheelConfig.planets || Object.keys(wheelConfig.planets).length === 0) {
        throw new Error('No planets data provided');
      }

      if (!wheelConfig.houses || wheelConfig.houses.length === 0) {
        throw new Error('No houses data provided');
      }

      // Log final configuration to verify types are included
      console.log('Creating WheelChart with config:', JSON.stringify(wheelConfig, null, 2));
      console.log('PrimaryAspectSettings:', wheelConfig.config?.primaryAspectSettings);
      console.log('NocturnaWheel keys:', Object.keys(NocturnaWheel));
      
      // Verify that types are present in primaryAspectSettings
      if (wheelConfig.config?.primaryAspectSettings && !wheelConfig.config.primaryAspectSettings.types) {
        console.error('ERROR: primaryAspectSettings.types is missing!');
        console.error('primaryAspectSettings:', wheelConfig.config.primaryAspectSettings);
      }
      
      // Create chart instance
      // The library exports a NocturnaWheel object with all components
      const { WheelChart } = NocturnaWheel;
      let chart;
      
      try {
        // Since v4.0.0, the library automatically rotates the wheel
        // to position the Ascendant (houses[0]) at 9 o'clock
        chart = new WheelChart(wheelConfig);
      } catch (e) {
        console.error('Error creating chart:', e);
        throw e;
      }
      
      console.log('Calling chart.render()...');
      const renderResult = chart.render();
      console.log('Render result:', renderResult);
      console.log('Chart rendered successfully');
      
      // Apply showHouses setting if specified
      const showHouses = chartConfig.renderOptions?.showHouses !== undefined 
        ? chartConfig.renderOptions.showHouses 
        : true;
      
      if (!showHouses) {
        console.log('Hiding houses display (showHouses = false)');
        if (typeof chart.toggleHouses === 'function') {
          chart.toggleHouses(false);
        } else {
          console.warn('chart.toggleHouses method not available');
        }
      }
      
      // Give library time to complete rendering (might be asynchronous)
      // This will be handled by Puppeteer's waitForFunction
      // The library automatically calculates ascendantAlignmentOffset from houseCusps
      // to position the Ascendant at the top of the chart
      
      // Library might need a moment to complete rendering
      // Wait a bit before checking content
      
      // Debug: Check what was actually rendered
      const checkSVGContent = () => {
        const svg = document.querySelector('#chart-container svg');
        const allSVGs = document.querySelectorAll('svg');
        
        console.log(`Total SVG elements in document: ${allSVGs.length}`);
        allSVGs.forEach((s, i) => {
          console.log(`SVG ${i}: ${s.children.length} children, parent: ${s.parentElement?.id || s.parentElement?.tagName}`);
        });
        
        if (svg) {
          const images = svg.querySelectorAll('image').length;
          const paths = svg.querySelectorAll('path').length;
          const lines = svg.querySelectorAll('line').length;
          const texts = svg.querySelectorAll('text').length;
          const groups = svg.querySelectorAll('g').length;
          const allElements = svg.querySelectorAll('*').length;
          
          console.log(`SVG content check: images=${images}, paths=${paths}, lines=${lines}, texts=${texts}, groups=${groups}, total=${allElements}`);
          
          // Check each group
          svg.querySelectorAll('g[id^="group-"]').forEach(g => {
            console.log(`Group ${g.id}: ${g.children.length} children`);
            if (g.children.length > 0) {
              console.log(`  First child: ${g.children[0].tagName}`);
              // Log all children for debugging
              Array.from(g.children).forEach((child, idx) => {
                console.log(`    Child ${idx}: ${child.tagName} ${child.id || ''} ${child.className || ''}`);
              });
            }
          });
          
          // Check if chart object has any methods we should call
          if (typeof chart.getSVG === 'function') {
            console.log('Chart has getSVG method');
          }
          if (typeof chart.update === 'function') {
            console.log('Chart has update method');
          }
        } else {
          console.error('SVG element not found after render!');
        }
      };
      
      // Check after render completes
      checkSVGContent();
      
    } catch (error) {
      console.error('Error rendering chart:', error);
      console.error('Error stack:', error.stack);
      document.getElementById('chart-container').innerHTML = 
        '<div style="color: red; padding: 20px;">Error rendering chart: ' + error.message + '</div>';
    }
  </script>
</body>
</html>

